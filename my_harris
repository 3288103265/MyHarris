import cv2
import numpy as np
import matplotlib.pyplot as plt


window_size = 7
harris_k = 0.06
harris_threshold = 0.5
nms_window = 24
# read source image first.
src = cv2.imread("src1.png", 0)
# cv2.imshow("src", src)

# blurImg = cv2.GaussianBlur(src, (5, 5), 0)
# cv2.namedWindow("Gaussian Blur")
# cv2.imshow("Gaussian Blur", blurImg)

"""
Calculate structure tensor.
"""
grad_x = cv2.Sobel(src, cv2.CV_32F, 1, 0, ksize=3)
grad_y = cv2.Sobel(src, cv2.CV_32F, 0, 1, ksize=3)

gradx = cv2.convertScaleAbs(grad_x)
grady = cv2.convertScaleAbs(grad_y)

# cv2.imshow("gradx", gradx)
# cv2.imshow("grady", grady)

ixx = gradx // 255 * gradx
iyy = grady // 255 * grady
ixy = gradx // 255 * grady

Ixx = cv2.GaussianBlur(ixx, (window_size, window_size), 0)
Iyy = cv2.GaussianBlur(iyy, (window_size, window_size), 0)
Ixy = cv2.GaussianBlur(ixy, (window_size, window_size), 0)

"""
Calculate Harris response.
"""
det = Ixx * Iyy - Ixy ** 2
trace = Ixx + Iyy
response = det - harris_k * trace
response = (response - response.min()) / (response.max() - response.min()) * 255
# _, response_threshold = cv2.threshold(response,
# #                                        harris_threshold*response.max(),
# #                                        255,
# #                                        cv2.THRESH_TOZERO)
# #
# # cv2.imshow("Harris Response", response_threshold)
"""
Get corner candidates.
"""
thresh = response.max() * harris_threshold
(height, weight) = response.shape
cornerList = []
for i in range(0, height):
    for j in range(0, weight):
        if response[i][j] > thresh:
            cornerList.append([i, j, response[i][j]])

cornerList.sort(key=lambda s: -s[2])
# cv2.imshow("Harris Response thresholded", response_threshold)
# cv2.imshow("gradx", gradx)
# cv2.imshow("grady", grady)
print(cornerList)
print(len(cornerList))

"""
non-maxima suppression.
"""
cornerList = cornerList[:500]
length = len(cornerList)
for i in range(length - nms_window):
    if cornerList[i][2] > 0:
        for j in range(1, nms_window + 1):
            if (abs(cornerList[i][0] - cornerList[i + j][0]) <= nms_window) and (
                    abs(cornerList[i][1] - cornerList[i + j][1]) <= nms_window):
                cornerList[i + j][2] = 0

for r in cornerList:
    if r[2] == 0:
        cornerList.remove(r)
cornerList = cornerList[:250]
print(cornerList)
print(len(cornerList))
# cv2.waitKey()
# cv2.destroyAllWindows()
